# C++内存管理详解

内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。



## 1 C++ 内存分配模式

在C++中，内存分成5个区，他们分别是栈、堆、自由存储区、静态存储区和常量存储区。

* 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
* 堆：就是那些由 `new`分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
* 自由存储区：就是那些由 `malloc` 分配的内存块，用 `free` 来释放。
* 静态存储区：全局变量和静态变量被分配到同一块内存中。
* 常量存储区 ：这是一块比较特殊的存储区，里面存放的是常量，不允许修改。



### 1.1 明确区分堆与栈

堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。
首先，我们举一个例子：

```c++
void f() { int* p=new int[5]; }
```

　　这条短短的一句话就包含了堆与栈，看到`new`，我们首先就应该想到，我们分配了一块堆内存，那么指针`p`呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针`p`。在程序会先确定在堆中分配内存的大小，然后调用`operator new`分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：

```
00401028 push 14h
0040102A call operator new (00401060)
0040102F add esp,4
00401032 mov dword ptr [ebp-8],eax
00401035 mov eax,dword ptr [ebp-8]
00401038 mov dword ptr [ebp-4],eax
```



好了，我们回到我们的主题：堆和栈究竟有什么区别？

* 管理方式不同 ： 对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生内存泄漏；

* 空间大小不同 ： 一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是 1M

* 能否产生碎片不同 ： 对于堆来讲，频繁的`new/delete`势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列。

* 生长方向不同 ： 对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

* 分配方式不同 ： 堆是由 `new` 产生的动态分配内存，而栈是静态分配的，由编译器完成，例如局部变量的分配。

* 分配效率不同 ： 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

  

  从这里我们可以看到，堆和栈相比，由于大量`new/delete`的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。

  

  虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。



### 1.2 如何避免产生野指针

* 规则1：用`malloc`或`new`申请内存之后，应该立即检查指针值是否为`NULL`。
* 规则2：不要忘记为数组和动态内存赋初值，防止将未被初始化的内存作为右值使用。
* 规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
* 规则4：动态内存的申请与释放必须配对，防止内存泄漏。
* 规则5：用 `free` 或 `delete` 释放了内存之后，立即将指针设置为 `NULL`，防止产生“野指针”。
* 规则6：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为 NULL，要么让它指向合法的内存。



## 2 字符指针和字符数组的对比

数组要么在静态存储区被创建（例如全局数组），要么在栈上被创建。数组名对应着一块内存，其地址和容量在生命期内保持不变，只有数组的内容可以改变。

指针可以指向任意类型的内存块，我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。

### 2.1 修改内容

需要注意的是，用 "world" 初始化 `char[]` 和 `char*` 有本质区别：

* `char a[] = "world";` 会将 "world" 存储在数组 `a` 所管理的内存区域中；
* `char* p = "world";` 会将 "world" 存储在静态存储区;

从而，可通过 `a` 去修改 "world"， 而不能通过 `p` 去修改。

```c++
#include <iostream>

void main()
{
	char a[] = "hello";
	a[0] = 'x';
	std::cout << a << std::endl;

	char* p = "world";  // "world" 是常量字符串，常量字符串的内容是不可以修改的
	// p[0] = 'x';  // ERROR : 常量字符串是不可以修改的  
	std::cout << p << std::endl;

	system("pause");
}
```

### 2.2 内容复制和比较

复制： `strcpy`

比较：`strcmp`

```c++
#include <iostream>
#include <cstring>

void main()
{
	char a[] = "hello";
	char b[10];
	strcpy(b, a);
	
	int len = strlen(b);
	char* p = new char[len];
	strcpy(p, b);
	
	if (strcmp(p, b) == 0) std::cout << "The same " << std::endl;
	system("pause");
}
```

### 2.3 计算内存容量

运算符`sizeof()` 可以计算出数组的容量，而没法计算出指针所指的内存容量。得知指针所指内存容量的唯一方法是在申请内存时记住它。

```c++
#include <iostream>

void main()
{
	char a[] = "world";
	std::cout << sizeof(a) << std::endl;  // 6

	char* p = "world";
	std::cout << sizeof(p) << std::endl;  // 8

	system("pause");
}
```



## 3 指针是如何被传递到内存的

编译器总要为函数的每个参数制作临时副本，设指针参数`p` 的副本是 `_p`，编译器使得`_p = p;`

如果函数体内的程序修改了`_p`所指内存的值，也就是`p`所指内存的值发生了变化。



如果`_p` 指向了新的内存地址，那么就只有`_p`所指内存地址改变了，而`p`丝毫未变。例如：

```c++
// Demo ： 函数参数为指针，函数内改变了指针所指向的内存地址，导致内存泄漏
#include <iostream>

void getMemory(char* p, int request_size)
{
	p = new char[request_size];
}

void main()
{
	char* arr = nullptr;
	const int request_size = 10;
	arr = getMemory(request_size);
	std::cout << arr << std::endl;  // ERROR : 访问未分配的内存空间
	system("pause");
}
```

这段代码是错误的，因为函数内改变了指针副本所指向的内存空间，然而函数外的指针却丝毫未变。这段代码有两个错误：

* `new` 出来的堆内存没有被`delete`，发生内存泄漏；
* `arr` 为空， `std::cout` 无法输出空指针。



所以当你需要修改指针参数所指向的内存空间时，请传递指针的指针。

```c++
// Demo : 当需要修改指针参数所指向的内存空间时，传递指针的指针
#include <iostream>

void getMemory(char** p, int request_size)
{
	*p = new char[request_size];
}

// 在这个示例中，可直接返回指针。由于 new 出来的是堆内存，不会被自动释放，必须调用 delete 来删除
char* getMemory(int request_size)
{
	char* p = new char[request_size];
	return p;
}

void main()
{
	char* arr = nullptr;
	const int request_size = 10;
	getMemory(&arr, request_size);
	for (int i = 0; i < request_size; i++) arr[i] = '1';
	std::cout << arr << std::endl;

	auto arr2 = getMemory(request_size);
	for (int i = 0; i < request_size; i++) arr2[i] = '2';
	std::cout << arr2 << std::endl;

	delete[] arr;
	delete[] arr2;
	system("pause");
}
```

需要注意一点：不要 `return` 栈内存中的指针，因为栈内存的变量会在函数结束时自动消亡。



## 参考

[C++内存管理详解](https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/)