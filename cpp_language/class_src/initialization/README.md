# C++ 初始化

变量的初始化在构造时提供其初值。

初值可以由`声明符`或 `new 表达式` 的初始化器部分提供。在函数调用时也会发生：函数形参及函数返回值亦会被初始化。



初始化器是下列之一：

```c++
// 括号中的任意表达式, 逗号分隔列表
(expression_list)
```

```c++
// 等号后面跟着一个表达式
= expression
```

```c++
// 花括号初始化器列表：表达式和其他花括号初始化器列表可以为空的逗号分隔列表
{ initialization_list }
```

根据其上下文，初始化器可以调用：

* 值初始化
* 直接初始化，例如 `std::string("hello");`
* 复制初始化，例如 `std::string s = "hello";`
* 列表初始化，例如 `std::string s {'a', 'b', 'c'};`
* 聚合初始化，例如 `char a[3] = {'a', 'b'};`
* 引用初始化，例如`char &c = a[0];`

如果没有提供初始化器，则应用默认初始化的规则。



## 复制初始化

复制初始化在下列情况进行：

1) 当声明非引用类型 `T` 的具名变量（自动、静态或线程局部），带有以等号的一个表达式所构成的初始化器时；

2) 当按值传递参数到函数时；

3) 当从具有返回值的函数返回时；

4) 当按值抛出或捕获异常时；

5) 作为列表初始化的一部分，以初始化提供了初始化器的每个元素



**注意**

复制初始化不如直接初始化自由：`explicit` 构造函数不是转换构造函数，不被复制初始化所考虑。



## 转换构造函数

不以说明符 `explicit` 声明，且可以单个参数调用的构造函数被称为转换构造函数(converting constructor)。

与只在直接初始化中被考虑的 `explicit`构造函数不同，转换构造函数还作为用户定义的转换序列中的一部分，在复制初始化中受到考虑。

隐式声明的及用户定义的非 `explicit` 复制构造函数与移动构造函数也是转换构造函数。





## 参考

[c++ 初始化](https://zh.cppreference.com/w/cpp/language/initialization)