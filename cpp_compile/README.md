# C++ 编译与内存

## 1 C++ 程序编译过程

编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。

* 编译预处理：处理以 `#` 开头的指令；

* 编译、优化：将源码 `.cpp` 文件翻译成 `.s` 汇编代码；

* 汇编：将汇编代码 `.s` 翻译成机器指令 `.o` 文件；

* 链接：汇编程序生成的目标文件，即 `.o` 文件，并不会立即执行，因为可能会出现：`.cpp` 文件中的函数引用了另一个 `.cpp` 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行程序的 `.exe` 文件。



![](.\compile.png)



链接分为两种：

* 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。

* 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。

  

二者的优缺点：

* 静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
* 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。



## 2 C++ 内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

* 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。
* 堆：动态申请的内存空间，就是由 `new/malloc` 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。
* 全局区/静态存储区：存放全局变量和静态变量，程序运行结束，操作系统自动释放。
* 常量存储区：存放的是常量，不允许修改，程序运行结束自动释放。
* 代码区（`.text` 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。



从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> 全局区/静态存储区 --> 堆 --> unused --> 栈 --> env



```c++
#include <iostream>
using namespace std;


int g_var = 0; // g_var 在全局区
char *gp_var;  // gp_var 在全局区

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```



## 3 栈和堆的区别

* 申请方式：栈是系统自动分配，堆是程序员主动申请。
* 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
* 栈在内存中是连续的一块空间（向低地址扩展），最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
* 申请效率：栈由系统自动分配，效率高，但程序员无法控制；堆由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
* 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。



## 4 静态变量与静态函数

C++ 中的 `static` 关键字用于控制变量的存储方式和可见性。`static` 关键字的作用：

* `static` 作用于局部变量：使得局部变量保存在静态存储区，保持变量内容的持久化。
* `static` 作用于全局变量：非`static`全局变量对整个工程可见，`static`全局变量仅对当前文件可见。
* `static` 作用于函数 ： `static` 函数只能在声明它的文件中调用，其他文件不能调用函数。
* `static` 作用于类内成员，由该类的所有对象共同维护和使用，从而实现同一个类的不同对象数据共享。
* 静态存储区中，所有字节默认都是 `0x00`。在初始化稀疏矩阵时，可省略将数据全置为0的操作，只需把不为0的几个元素赋值。



### 4.1 为什么类的静态成员函数不能为虚函数

* 静态函数与非静态函数的主要区别 ：静态成员函数没有 `this` 指针。
* `static` 成员不属于任何单个类对象。它属于整个类，由所有类对象共同维护。



虚函数的实现机理： 虚函数表(`vtable`) + 虚表指针 (`vptr`)。其中 `vptr` 在类的构造函数中创建生成，`vptr`只能通过 `this` 指针来访问它。而静态成员函数没有`this` 指针，从而无法访问 `vptr`。



虚函数的调用关系：`this` -> `vptr` -> `vtable` -> `virtual function`



## 5 全局变量的声明与定义

变量声明和定义的区别：

```c++
extern int a;      // 声明一个全局变量
int a;             // 定义一个全局变量
int a = 0;         // 定义一个全局变量，并赋初值
extern int a = 0;  // 
```



* `ODR` 规则 ： 在 C++ 中，定义只能有一处，而声明可以有多处。

* 定义引起内存分配，声明则不会。
* 变量的声明，默认就是 `extern`



## 5.1 不能在头文件中定义全局变量

如果在头文件中定义全局变量，当该头文件被多个文件`include` 时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能在头文件中定义全局变量。

解决办法：将头文件中的全局变量声明为 `extern`， 在某一个文件中去定义。



```c++
// extern 全局变量声明
#ifndef __GLOBAL_DEMO_H__
#define __GLOBAL_DEMO_H__

extern int a;
void test();

#endif
```



```c++
// 全局变量在某个文件中定义
#include "global_demo.h"

int a;

void test()
{
	a = 3;
}
```



```c++
// 使用全局变量
#include "global_demo.h"
#include <iostream>

int main()
{
	test();
	std::cout << a << std::endl;
	return 0;
}
```









## 参考

[C++头文件如何正确定义全局变量](https://norcy.github.io/wiki/C++/C++%E5%A4%B4%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/)

